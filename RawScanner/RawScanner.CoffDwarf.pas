////////////////////////////////////////////////////////////////////////////////
//
//  ****************************************************************************
//  * Project   : ProcessMM
//  * Unit Name : RawScanner.CoffDwarf.pas
//  * Purpose   : Декларация типов используемых для чтения отладочной
//  *           : информации в форматах COFF и DWARF.
//  * Author    : Александр (Rouse_) Багель
//  * Copyright : © Fangorn Wizards Lab 1998 - 2023.
//  * Version   : 1.1.15
//  * Home Page : http://rouse.drkb.ru
//  * Home Blog : http://alexander-bagel.blogspot.ru
//  ****************************************************************************
//  * Stable Release : http://rouse.drkb.ru/winapi.php#pmm2
//  * Latest Source  : https://github.com/AlexanderBagel/ProcessMemoryMap
//  ****************************************************************************
//

// https://wiki.osdev.org/COFF
// https://dwarfstd.org/doc/dwarf_1_1_0.pdf
// https://refspecs.linuxfoundation.org/dwarf/dwarf-2.0.0.pdf
// https://dwarfstd.org/doc/Dwarf3.pdf
// https://dwarfstd.org/doc/DWARF4.pdf
// https://dwarfstd.org/doc/DWARF5.pdf

unit RawScanner.CoffDwarf;

interface

uses
  Windows,
  Classes,
  SysUtils,
  Math,
  Generics.Collections,
  RawScanner.Types,
  RawScanner.SymbolStorage;

const
  // Table 7.25: Line number standard opcode encodings
  DW_LNS_copy = $01;
  DW_LNS_advance_pc = $02;
  DW_LNS_advance_line = $03;
  DW_LNS_set_file = $04;
  DW_LNS_set_column = $05;
  DW_LNS_negate_stmt = $06;
  DW_LNS_set_basic_block = $07;
  DW_LNS_const_add_pc = $08;
  DW_LNS_fixed_advance_pc = $09;
  DW_LNS_set_prologue_end = $0a;
  DW_LNS_set_epilogue_begin = $0b;
  DW_LNS_set_isa = $0c;

  // Table 7.26: Line number extended opcode encodings
  DW_LNE_end_sequence = $01;
  DW_LNE_set_address = $02;
  DW_LNE_define_file = $03; // not used in DWARF 5 - Reserved
  DW_LNE_set_discriminator = $04; // DWARF 4-5
  DW_LNE_lo_user = $80;
  DW_LNE_hi_user = $ff;

  // Table 7.27: Line number header entry format encodings
  // DWARF 5 only!
  DW_LNCT_path = $1;
  DW_LNCT_directory_index = $2;
  DW_LNCT_timestamp = $3;
  DW_LNCT_size = $4;
  DW_LNCT_MD5 = $5;
  DW_LNCT_lo_user = $2000;
  DW_LNCT_hi_user = $3fff;

type
  TDebugCoffSymbol = packed record
    Name: DWORD;
    StrOfs: DWORD;
    Value: DWORD;
    Section: Word;
    Empty: Word;
    Typ: Byte;
    Aux: Byte;
  end;

  TCoffFunction = record
    FuncAddrVA: ULONG_PTR64;
    DisplayName: string;
    Executable: Boolean;
  end;

  // 6.2.2 State Machine Registers
  TStateMachineRegisters = record

    // The program-counter value corresponding to a machine instruction
    // generated by the compiler.

    address : ULONG_PTR64;

    // An unsigned integer indicating the identity of the source file
    // corresponding to a machine instruction.

    file_id : DWORD;

    // An unsigned integer indicating a source line number. Lines are numbered
    // beginning at 1. The compiler may emit the value 0 in cases where an
    // instruction cannot be attributed to any source line.

    line : Integer;

    // An unsigned integer indicating a column number within a source line.
    // Columns are numbered beginning at 1. The value 0 is reserved to indicate
    // that a statement begins at the “left edge” of the line.

    column : DWORD;

    // A boolean indicating that the current instruction is a recommended
    // breakpoint location. A recommended breakpoint location is intended to
    // "represent" a line, a statement and/or a semantically distinct subpart
    // of a statement.

    is_stmt : Boolean;

    // A boolean indicating that the current instruction is the beginning
    // of a basic block

    basic_block : Boolean;

    // A boolean indicating that the current address is that of the first byte after
    // the end of a sequence of target machine instructions.

    end_sequence : Boolean;

    // DWARF3

    // A boolean indicating that the current address is one (of possibly many)
    // where execution should be suspended for an entry breakpoint of a function.

    prolouge_end : Boolean;

    // A boolean indicating that the current address is one (of possibly many)
    // where execution should be suspended for an exit breakpoint of a function.

    epilouge_begin : Boolean;

    // An unsigned integer whose value encodes the applicable instruction set
    // architecture for the current instruction.

    // The encoding of instruction sets should be shared by all users of a given
    // architecture. It is recommended that this encoding be defined by the ABI
    // authoring committee for each architecture.

    isa : DWORD;

    // DWARF 4

    // An unsigned integer identifying the block to
    // which the current instruction belongs.
    // Discriminator values are assigned arbitrarily by
    // the DWARF producer and serve to distinguish
    // among multiple blocks that may all be
    // associated with the same source file, line, and
    // column. Where only one block exists for a given
    // source position, the discriminator value is be
    // zero.

    discriminator: DWORD;

    // DWARF 5

    // An unsigned integer representing the index of
    // an operation within a VLIW instruction. The
    // index of the first operation is 0. For non-VLIW
    // architectures, this register will always be 0.

    op_index: DWORD;

  end;

  TFileEntry = record
    FileName: string;
    DirectoryIndex: Int64;
    FileTime: UInt64;
    FileLength: UInt64;
  end;

  // 6.2.4 The Line Number Program Header (for DWARF 1-4)
  TDwarfLineNumberProgramHeader32 = packed record

    // The size in bytes of the line number information for this compilation unit,
    // not including the unit_length field itself

    unit_length: DWORD;

    // This number is specific to the line number information and
    // is independent of the DWARF version number.

    version: Word;

    // The number of bytes following the header_length field to the beginning
    // of the first byte of the line number program itself.

    header_length: DWORD;

    // The size in bytes of the smallest target machine instruction. Line number program opcodes
    // that alter the address register first multiply their operands by this value.

    minimum_instruction_length: Byte;

    // A simple approach to building line number information when machine instructions are
    // emitted in an order corresponding to the source program is to set default_is_stmt to “true”
    // and to not change the value of the is_stmt register within the line number program. One
    // matrix entry is produced for each line that has code generated for it. The effect is that every
    // entry in the matrix recommends the beginning of each represented line as a breakpoint
    // location. This is the traditional practice for unoptimized code.
    // A more sophisticated approach might involve multiple entries in the matrix for a line
    // number; in this case, at least one entry (often but not necessarily only one) specifies a
    // recommended breakpoint location for the line number. DW_LNS_negate_stmt opcodes in
    // the line number program control which matrix entries constitute such a recommendation and
    // default_is_stmt might be either “true” or “false”. This approach might be used as part of
    // support for debugging optimized code.

    default_is_stmt: Boolean;

    // This parameter affects the meaning of the special opcodes.

    line_base: ShortInt;

    // This parameter affects the meaning of the special opcodes.

    line_range: Byte;

    // The number assigned to the first special opcode.
    // Opcode base is typically one greater than the highest-numbered standard opcode defined for
    // the specified version of the line number information (12 in DWARF Version 3, 9 in DWARF
    // Version 2). If opcode_base is less than the typical value, then standard opcode numbers
    // greater than or equal to the opcode base are not used in the line number table of this unit
    // (and the codes are treated as special opcodes). If opcode_base is greater than the typical
    // value, then the numbers between that of the highest standard opcode and the first special
    // opcode (not inclusive) are used for vendor specific extensions.

    opcode_base: Byte;

    // This array specifies the number of LEB128 operands for each of the standard opcodes. The
    // first element of the array corresponds to the opcode whose value is 1, and the last element
    // corresponds to the opcode whose value is opcode_base - 1. By increasing opcode_base,
    // and adding elements to this array, new standard opcodes can be added, while allowing
    // consumers who do not know about these new opcodes to be able to skip them.

    // standard_opcode_lengths: array of Byte;

    // The sequence contains an entry for each path that was searched for included source files in
    // this compilation. (The paths include those directories specified explicitly by the user for the
    // compiler to search and those the compiler searches without explicit direction). Each path
    // entry is either a full path name or is relative to the current directory of the compilation. The
    // current directory of the compilation is understood to be the first entry and is not explicitly
    // represented. Each entry is a null-terminated string containing a full path name. The last entry
    // is followed by a single null byte.

    // include_directories: array of string;

    // The sequence contains an entry for each source file that contributed to the line number
    // information for this compilation unit or is used in other contexts, such as in a declaration
    // coordinate or a macro file inclusion. Each entry consists of the following values:
    // • A null-terminated string containing the file name.
    // • An unsigned LEB128 number representing the directory index of the directory in which
    // the file was found.
    // • An unsigned LEB128 number representing the (implementation-defined) time of last
    // modification for the file.
    // • An unsigned LEB128 number representing the length in bytes of the file.
    // A compiler may choose to emit LEB128(0) for the time and length fields to indicate that this
    // information is not available. The last entry is followed by a single null byte.
    // The directory index represents an entry in the include_directories section. The index is
    // LEB128(0) if the file was found in the current directory of the compilation, LEB128(1) if it
    // was found in the first directory in the include_directories section, and so on. The
    // directory index is ignored for file names that represent full path names.

    // file_names: array of TFileEtry;

  end;

  TDwarfLineNumberProgramHeader64 = packed record
    magic: DWORD;
    unit_length: UInt64;
    version: Word;
    header_length: UInt64;
    minimum_instruction_length: Byte;
    default_is_stmt: Boolean;
    line_base: ShortInt;
    line_range: Byte;
    opcode_base: Byte;
  end;

  TSectionParams = record
    AddressVA: ULONG_PTR64;
    AddressRaw: DWORD;
    SizeOfRawData: DWORD;
    IsExecutable: Boolean;
  end;

  // для PE и ELF реализации разные, поэтому работаем через абстракцию
  TAbstractImageGate = class
  private
    FModuleIndex: Integer;
  public
    function SectionAtIndex(AIndex: Integer; out ASection: TSectionParams): Boolean; virtual; abstract;
    function SectionAtName(const AName: string; out ASection: TSectionParams): Boolean; virtual; abstract;
    property ModuleIndex: Integer read FModuleIndex write FModuleIndex;
  end;

  TCoffDebugInfo = class
  private
    FImage: TAbstractImageGate;
    FCoffList: TList<TDebugCoffSymbol>;
    FCoffStrings: TList<TCoffFunction>;
  public
    constructor Create(AImage: TAbstractImageGate);
    destructor Destroy; override;
    function Load(AStream: TStream; PointerToSymbolTable: ULONG_PTR64;
      NumberOfSymbols: Integer): Boolean;
    function SymbolAtName(const AName: string): Integer;
    property CoffStrings: TList<TCoffFunction> read FCoffStrings;
  end;

  EOverDataStreamException = class(Exception);

  /// <summary>
  ///  Стрим сидит поверх другого стрима и дает читать/писать
  ///  только в пределах указанной области
  /// </summary>
  TUnitDataStream = class(TStream)
  strict private
    FDataStream: TStream;
    FStartData, FEndData,
    FSize, FPosition: Int64;
  protected
    function GetSize: Int64; override;
    procedure ReNew(ASize: Int64); overload;
    procedure ReNew(AStartData, ASize: Int64); overload;
    procedure ReNew(ADataStream: TStream; AStartData, ASize: Int64); overload;
  public
    constructor Create(ADataStream: TStream; AStartData, AEndData: Int64);
    function GetNativePosition: Int64;
    function EOF: Boolean;
    function Read(var Buffer; Count: Longint): Longint; override;
    function Seek(const Offset: Int64; Origin: TSeekOrigin): Int64; overload; override;
    function ReadByte: Byte;
    function ReadWord: Word;
    // 7.6 Variable Length Data
    function ReadLEB128: Int64;
    function ReadULEB128: UInt64;
    function ReadString: string;
    function ReadFileEntry: TFileEntry;
  end;

  TLineData = record
    AddrVA: ULONG_PTR64;
    FileId: Word;
    Line: DWORD;
  end;

  TLineList = TList<TLineData>;

  EDwarfNotImplemented = class(Exception);

  TDwarfLinesUnit = class
  private
    FModuleIndex, FUnitIndex: Integer;
    FOpcodeLen: array of Byte;
    FDirList: TStringList;
    FFiles: TList<TFileEntry>;
    FLines: TLineList;
  public
    constructor Create(AModuleIndex, AUnitIndex: Integer);
    destructor Destroy; override;
    function Load(AStream: TUnitDataStream): Boolean;
    function GetFilePath(FileId: Word): string;
    property Lines: TLineList read FLines;
  end;

  TUnitList = TObjectList<TDwarfLinesUnit>;

  TDwarfDebugInfo = class
  private
    FImage: TAbstractImageGate;
    FUnits: TUnitList;
    procedure LoadLines(AStream: TStream);
  public
    constructor Create(AImage: TAbstractImageGate);
    destructor Destroy; override;
    function Load(AStream: TStream): Boolean;
    property Units: TUnitList read FUnits;
  end;

// дабы не прокидывать настройку от GUI до внутреннего класса
// она будет висеть глобальным флагом, так проще...
var
  NeedDemangleName: Boolean = True;

implementation

procedure RaiseNotImplemented(ADwarfVersion: Word);
begin
  {$MESSAGE 'Поддержка DWARF5'}
  raise EDwarfNotImplemented.CreateFmt('DWARF %d not implemented.', [ADwarfVersion]);
end;

function DemangleName(const AName: string; Executable: Boolean): string;
const
  indClassOperatorMethod = '_$__$$_$';
  indClassMethod = '_$__$$_';
  indMethod = '_$$_';
  indClass = '$_$';
  indResult = '$$';
  indSeparator = '_';
  indParam = '$';

type
  TIdentifierType = (itUnknown, itUnit, itClass, itMethod, itParamType, itResultType, itEnd);
  TIdentifierTypes = set of TIdentifierType;

var
  pCursor, pMax: PChar;

  function Check(const Ind: string): Boolean;
  begin
    if pCursor + Length(Ind) > pMax then
      Result := False
    else
      Result := StrLComp(pCursor, @Ind[1], Length(Ind)) = 0;
  end;

  function ReadStr: string;
  var
    pStart: PChar;
  begin
    pStart := pCursor;
    while (pCursor < pMax) and (pCursor^ <> indParam) do
    begin
      if pCursor^ = indSeparator then
      begin
        if Check(indMethod) or Check(indClassMethod) or Check(indClassOperatorMethod) then
          Break;
      end;
      Inc(pCursor);
    end;
    SetLength(Result, pCursor - pStart);
    if Result <> '' then
      Move(pStart^, Result[1], Length(Result) * SizeOf(Char));
  end;

  function ReadIdentifierType(APrevios: TIdentifierType): TIdentifierType;
  begin
    if pCursor >= pMax then
      Exit(itEnd);
    Result := itUnknown;

    if Check(indClassOperatorMethod) then
    begin
      if APrevios = itClass then
      begin
        Result := itMethod;
        Inc(pCursor, Length(indClassOperatorMethod));
      end
      else
        Result := itUnknown;
      Exit;
    end;

    if Check(indClassMethod) then
    begin
      if APrevios = itClass then
      begin
        Result := itMethod;
        Inc(pCursor, Length(indClassMethod));
      end
      else
        Result := itUnknown;
      Exit;
    end;

    if Check(indMethod) then
    begin
      if APrevios = itUnit then
      begin
        Result := itMethod;
        Inc(pCursor, Length(indMethod));
      end
      else
        Result := itUnknown;
      Exit;
    end;

    if Check(indClass) then
    begin
      if APrevios = itUnit then
      begin
        Result := itClass;
        Inc(pCursor, Length(indClass));
      end
      else
        Result := itUnknown;
      Exit;
    end;

    if Check(indResult) then
    begin
      if APrevios in [itMethod, itParamType] then
      begin
        Result := itResultType;
        Inc(pCursor, Length(indResult));
      end
      else
        Result := itUnknown;
      Exit;
    end;

    if Check(indParam) then
    begin
      if APrevios in [itMethod, itParamType] then
      begin
        Result := itParamType;
        Inc(pCursor, Length(indParam));
      end
      else
        Result := itUnknown;
      Exit;
    end;

  end;

var
  AUnitName, AClassName, AMethodName, AParamsTypeList, AResultType: string;
  NextIdentifierType: TIdentifierType;
begin
  if AName = '' then
  begin
    Result := '';
    Exit;
  end;

  if not Executable then
  begin
    Result := AName;
    Exit;
  end;

  // системные функции
  if AName[1] = '_' then
  begin
    Result := AName;
    Exit;
  end;

  pCursor := @AName[1];
  pMax := pCursor;
  Inc(pMax, Length(AName));

  AUnitName := ReadStr;
  NextIdentifierType := itUnit;
  while NextIdentifierType <> itEnd do
  begin
    NextIdentifierType := ReadIdentifierType(NextIdentifierType);
    case NextIdentifierType of
      itUnknown: Break;
      itClass: AClassName := ReadStr;
      itMethod: AMethodName := ReadStr;
      itParamType:
      begin
        if AParamsTypeList = '' then
          AParamsTypeList := ReadStr
        else
          AParamsTypeList := AParamsTypeList + ', ' + ReadStr;
      end;
      itResultType:
        AResultType := ReadStr;
    end;
  end;

  // не смогли распасить или имя метода отсутствует, значит оставляем как есть
  if (NextIdentifierType = itUnknown) or (AMethodName = '') then
  begin
    Result := AName;
    Exit;
  end;

  Result := '[' + AUnitName + '] ';
  if AClassName <> '' then
    Result := Result + AClassName + '.';
  Result := Result + AMethodName;
  if AParamsTypeList <> '' then
    Result := Result + '(' + AParamsTypeList + ')';
  if AResultType <> '' then
    Result := Result + ': ' + AResultType;
end;

function InitStateMachineRegisters(DefaultIsStmt: Boolean): TStateMachineRegisters;
begin
  FillChar(Result, SizeOf(Result), 0);
  Result.file_id := 1;
  Result.line := 1;
  Result.is_stmt := DefaultIsStmt;
end;

function CalcAddPCValue(Opcode: Byte; const AHeader: TDwarfLineNumberProgramHeader64): ULONG_PTR64;
begin
  Result := (Opcode - AHeader.opcode_base) div AHeader.line_range * AHeader.minimum_instruction_length;
end;

{ TCoffDebugInfo }

constructor TCoffDebugInfo.Create(AImage: TAbstractImageGate);
begin
  FImage := AImage;
  FCoffList := TList<TDebugCoffSymbol>.Create;
  FCoffStrings := TList<TCoffFunction>.Create;
end;

destructor TCoffDebugInfo.Destroy;
begin
  FCoffList.Free;
  FCoffStrings.Free;
  inherited;
end;

function TCoffDebugInfo.Load(AStream: TStream;
  PointerToSymbolTable: ULONG_PTR64; NumberOfSymbols: Integer): Boolean;
var
  I, SectionIndex: Integer;
  Buff: array [Byte] of AnsiChar;
  ASection: TSectionParams;
  StrStartPosition, StrEndPosition: Int64;
  ACoffFunction: TCoffFunction;
  SymbolData: TSymbolData;
begin
  FCoffList.Count := NumberOfSymbols;
  AStream.Position := PointerToSymbolTable;
  for I := 0 to FCoffList.Count - 1 do
    AStream.ReadBuffer(FCoffList.List[I], SizeOf(TDebugCoffSymbol));
  StrStartPosition := AStream.Position;
  StrEndPosition := AStream.Size;
  Buff[255] := #0;
  for I := 0 to FCoffList.Count - 1 do
  begin
    // если у символа не указан номер секции, значит мы не можем рассчитать его адрес
    // но тогда нам и имя его не нужно
    SectionIndex := FCoffList.List[I].Section - 1;
    if SectionIndex < 0 then
      Continue;
    if FCoffList.List[I].Name = 0 then
    begin
      AStream.Position := StrStartPosition + FCoffList.List[I].StrOfs;
      AStream.ReadBuffer(Buff[0], Min(255, StrEndPosition - AStream.Position));
    end
    else
    begin
      Move(FCoffList.List[I].Name, Buff[0], 8);
      Buff[9] := #0;
    end;
    if FImage.SectionAtIndex(SectionIndex, ASection) then
      ACoffFunction.FuncAddrVA := FCoffList.List[I].Value + ASection.AddressVA
    else
      // если секции нет, то и работать с таким символом не получится
      Continue;

    ACoffFunction.Executable := ASection.IsExecutable;
    ACoffFunction.DisplayName := string(PAnsiChar(@Buff[0]));
    if NeedDemangleName then
      ACoffFunction.DisplayName := DemangleName(ACoffFunction.DisplayName, ACoffFunction.Executable);

    SymbolData.AddrVA := ACoffFunction.FuncAddrVA;
    if ACoffFunction.Executable then
      SymbolData.DataType := sdtCoffFunction
    else
      SymbolData.DataType := sdtCoffData;
    SymbolData.Binary.ModuleIndex := FImage.ModuleIndex;
    SymbolData.Binary.ListIndex := FCoffStrings.Count;
    SymbolStorage.Add(SymbolData);

    FCoffStrings.Add(ACoffFunction);
  end;

  Result := FCoffStrings.Count > 0;
end;

function TCoffDebugInfo.SymbolAtName(const AName: string): Integer;
begin
  Result := -1;
  for var I := 0 to FCoffStrings.Count - 1 do
    if AnsiSameText(AName, FCoffStrings.List[I].DisplayName) then
      Exit(I);
end;

{ TUnitDataStream }

constructor TUnitDataStream.Create(ADataStream: TStream; AStartData,
  AEndData: Int64);
begin
  ReNew(ADataStream, AStartData, AEndData);
end;

function TUnitDataStream.EOF: Boolean;
begin
  Result := FPosition >= FSize;
end;

function TUnitDataStream.GetNativePosition: Int64;
begin
  if FDataStream is TUnitDataStream then
    Result := TUnitDataStream(FDataStream).GetNativePosition
  else
    Result := FDataStream.Position;
end;

function TUnitDataStream.GetSize: Int64;
begin
  Result := FSize;
end;

function TUnitDataStream.Read(var Buffer; Count: Longint): Longint;
begin
  FDataStream.Position := FStartData + FPosition;
  if Count > FSize - FPosition then
    Count := FSize - FPosition;
  Result := FDataStream.Read(Buffer, Count);
  Inc(FPosition, Result);
end;

function TUnitDataStream.ReadByte: Byte;
begin
  ReadBuffer(Result, SizeOf(Result));
end;

function TUnitDataStream.ReadFileEntry: TFileEntry;
begin
  Result.FileName := ReadString;
  if Result.FileName <> '' then
  begin
    Result.DirectoryIndex := ReadLEB128;
    Result.FileTime := ReadULEB128;
    Result.FileLength := ReadULEB128;
  end;
end;

function TUnitDataStream.ReadLEB128: Int64;
var
  Chunk, ChunkShift: Int64;
begin
  Result := 0;
  ChunkShift := 0;
  Chunk := 0;
  ReadBuffer(Chunk, 1);
  while ChunkShift < 63 do
  begin
    Result := Result or ((Chunk and $7F) shl ChunkShift);
    Inc(ChunkShift, 7);
    if Chunk and $80 = 0 then
      Break;
    ReadBuffer(Chunk, 1);
  end;
  // выставление знака который хранится в 7 бите
  // последнего прочитанного семибитного чанка
  ChunkShift := 1 shl (ChunkShift - 1);
  Result := Result or not ((Result and ChunkShift) - 1);
end;

function TUnitDataStream.ReadString: string;
var
  ACapacity, ACursor: Integer;
  AChar: AnsiChar;
begin
  ACursor := 0;
  ACapacity := 24;
  SetLength(Result, ACapacity);
  repeat
    ReadBuffer(AChar, 1);
    Inc(ACursor);
    if ACursor > ACapacity then
    begin
      Inc(ACapacity, 16);
      SetLength(Result, ACapacity);
    end;
    Result[ACursor] := Char(AChar);
  until AChar = #0;
  SetLength(Result, ACursor - 1);
end;

function TUnitDataStream.ReadULEB128: UInt64;
var
  Chunk, ChunkShift: Int64;
begin
  Result := 0;
  ChunkShift := 0;
  Chunk := 0;
  ReadBuffer(Chunk, 1);
  while ChunkShift < 63 do
  begin
    Result := Result or ((Chunk and $7F) shl ChunkShift);
    Inc(ChunkShift, 7);
    if Chunk and $80 = 0 then
      Break;
    ReadBuffer(Chunk, 1);
  end;
end;

function TUnitDataStream.ReadWord: Word;
begin
  ReadBuffer(Result, SizeOf(Result));
end;

procedure TUnitDataStream.ReNew(ADataStream: TStream; AStartData,
  ASize: Int64);
begin
  FDataStream := ADataStream;
  FStartData := AStartData;
  FEndData := FStartData + ASize;
  FPosition := 0;
  FSize := ASize;
end;

procedure TUnitDataStream.ReNew(ASize: Int64);
begin
  ReNew(FDataStream, FStartData, ASize);
end;

procedure TUnitDataStream.ReNew(AStartData, ASize: Int64);
begin
  ReNew(FDataStream, AStartData, ASize);
end;

function TUnitDataStream.Seek(const Offset: Int64; Origin: TSeekOrigin): Int64;
begin
  case Origin of
    soBeginning: FPosition := Offset;
    soCurrent: Inc(FPosition, Offset);
    soEnd: FPosition := Size + Offset;
  end;
  if FPosition < 0 then
    FPosition := 0;
  if FPosition > FSize then
    FPosition := FSize;
  Result := FPosition;
end;

{ TDwarfLinesUnit }

constructor TDwarfLinesUnit.Create(AModuleIndex, AUnitIndex: Integer);
begin
  FModuleIndex := AModuleIndex;
  FUnitIndex := AUnitIndex;
  FDirList := TStringList.Create;
  FFiles := TList<TFileEntry>.Create;
  FLines := TLineList.Create;
end;

destructor TDwarfLinesUnit.Destroy;
begin
  FDirList.Free;
  FFiles.Free;
  FLines.Free;
  inherited;
end;

function TDwarfLinesUnit.GetFilePath(FileId: Word): string;
begin
  Result := '';
  if FileId > FFiles.Count then
    Exit;
  with FFiles.List[FileId - 1] do
  begin
    if (DirectoryIndex - 1 >= 0) and (FDirList.Count > DirectoryIndex - 1) then
      Result := IncludeTrailingPathDelimiter(FDirList[DirectoryIndex - 1]);
    Result := Result + FileName;
  end;
end;

function TDwarfLinesUnit.Load(AStream: TUnitDataStream): Boolean;
const
  Header64Magic = DWORD(-1);
var
  UnitStream: TUnitDataStream;
  Magic: DWORD;
  Header32: TDwarfLineNumberProgramHeader32;
  Header64: TDwarfLineNumberProgramHeader64;
  HeaderLength: UInt64;
  TmpString: string;
  FileEntry: TFileEntry;
  SmRegisters: TStateMachineRegisters;
  opcode: Byte;
  ExtendedLength: UInt64;
  AddToMatrix: Boolean;
  LineData: TLineData;
  SymbolData: TSymbolData;
  AddrVAInited: Boolean;
begin
  Result := True;

  UnitStream := TUnitDataStream.Create(AStream, AStream.Position, 0);
  try

    //  In the 32-bit DWARF format, an initial length field (see Section 7.2.2) is an unsigned 32-bit
    // integer (which must be less than 0xffffff00); in the 64-bit DWARF format, an initial
    // length field is 96 bits in size, and has two parts:
    // • The first 32-bits have the value 0xffffffff.
    // • The following 64-bits contain the actual length represented as an unsigned 64-bit integer.
    // This representation allows a DWARF consumer to dynamically detect that a DWARF section
    // contribution is using the 64-bit format and to adapt its processing accordingly.

    AStream.ReadBuffer(Magic, SizeOf(Magic));
    if Magic = Header64Magic then
    begin
      Header64.magic := Header64Magic;
      AStream.ReadBuffer(Header64.unit_length, SizeOf(Header64) - SizeOf(Magic));
      if Header64.unit_length = 0 then
        Exit(False);
      Inc(Header64.unit_length, SizeOf(Header64.unit_length) + SizeOf(Magic));
      HeaderLength := SizeOf(Header64);
    end
    else
    begin
      Header32.unit_length := Magic;
      if Header32.unit_length = 0 then
        Exit(False);
      AStream.ReadBuffer(Header32.version, SizeOf(Header32) - SizeOf(Magic));
      Header64.Magic := Header64Magic;
      Header64.unit_length := Header32.unit_length + SizeOf(Header32.unit_length);
      Header64.version := Header32.version;
      Header64.header_length := Header32.header_length;
      Header64.minimum_instruction_length := Header32.minimum_instruction_length;
      Header64.default_is_stmt := Header32.default_is_stmt;
      Header64.line_base := Header32.line_base;
      Header64.line_range := Header32.line_range;
      Header64.opcode_base := Header32.opcode_base;
      HeaderLength := SizeOf(Header32);
    end;

    UnitStream.ReNew(Header64.unit_length);
    UnitStream.Position := HeaderLength;

    // читаем количество LEB128 операндов для каждого опкода
    // пока не понятно что это
    SetLength(FOpcodeLen, Header64.opcode_base);
    UnitStream.ReadBuffer(FOpcodeLen[1], Header64.opcode_base - 1);

    // начиная с пятого в заголовке пошли изменения, надо тестировать
    if Header64.version >= 5 then
      RaiseNotImplemented(Header64.version);

    // читаем директории
    repeat
      TmpString := UnitStream.ReadString;
      if TmpString <> '' then
        FDirList.Add(TmpString);
    until TmpString = '';

    // читаем список файлов
    repeat
      FileEntry := UnitStream.ReadFileEntry;
      if FileEntry.FileName <> '' then
        FFiles.Add(FileEntry);
    until FileEntry.FileName = '';

    // через машину состояний парсим информацию о линиях
    SmRegisters := InitStateMachineRegisters(Header64.default_is_stmt);
    AddrVAInited := False;
    AddToMatrix := False;
    opcode := UnitStream.ReadByte;
    while not UnitStream.EOF do
    begin
      case opcode of
        // обработка расширенных опкодов, начинающихся с нуля
        0:
        begin
          // минус один т.к. включает размер опкода
          ExtendedLength := UnitStream.ReadULEB128 - 1;
          opcode := UnitStream.ReadByte;

          case opcode of

            // The DW_LINE_end_sequence opcode takes no operands. It sets the end_sequence register
            // of the state machine to “true” and appends a row to the matrix using the current values of the
            // state-machine registers. Then it resets the registers to the initial values specified above (see
            // Section 6.2.2). Every line number program sequence must end with a
            // DW_LNE_end_sequence instruction which creates a row whose address is that of the byte
            // after the last target machine instruction of the sequence.

            DW_LNE_end_sequence:
            begin
              SmRegisters.end_sequence := True;
              AddToMatrix := True;
            end;

            // The DW_LNE_set_address opcode takes a single relocatable address as an
            // operand. The size of the operand is the size of an address on the target
            // machine. It sets the address register to the value given by the relocatable
            // address and sets the op_index register to 0.

            // All of the other line number program opcodes that affect the address register add a delta to
            // it. This instruction stores a relocatable value into it instead.

            DW_LNE_set_address:
            begin
              SmRegisters.address := 0;
              SmRegisters.op_index := 0;
              UnitStream.ReadBuffer(SmRegisters.address, ExtendedLength);
              AddrVAInited := SmRegisters.address <> 0;
            end;

            // The DW_LNE_define_file opcode takes four operands:
            // 1. A null-terminated string containing a source file name.
            // 2. An unsigned LEB128 number representing the directory index of the directory in which
            // the file was found.
            // 3. An unsigned LEB128 number representing the time of last modification of the file.
            // 4. An unsigned LEB128 number representing the length in bytes of the file.
            // The time and length fields may contain LEB128(0) if the information is not available.

            // The directory index represents an entry in the include_directories section of the line
            // number program header. The index is LEB128(0) if the file was found in the current
            // directory of the compilation, LEB128(1) if it was found in the first directory in the
            // include_directories section, and so on. The directory index is ignored for file names that
            // represent full path names.
            // The files are numbered, starting at 1, in the order in which they appear; the names in the
            // header come before names defined by the DW_LNE_define_file instruction. These numbers
            // are used in the file register of the state machine.

            DW_LNE_define_file:
            begin
              if Header64.version < 5 then
              begin
                FileEntry := UnitStream.ReadFileEntry;
                if FileEntry.FileName <> '' then
                  FFiles.Add(FileEntry);
              end
              else
              begin
                // The DW_LNE_define_file operation defined in earlier versions of DWARF is deprecated
                // 5 in DWARF Version 5.
                RaiseNotImplemented(Header64.version);
              end;
            end;

            // The DW_LNE_set_discriminator opcode takes a single parameter, an
            // unsigned LEB128 integer. It sets the discriminator register to the new value.

            DW_LNE_set_discriminator:
            begin
              // больше про дискриминатор ничего не написано
              // мол читать - читаем, а что дальше делать... не понятно
              if Header64.version >= 5 then
                SmRegisters.discriminator := UnitStream.ReadULEB128
              else
                UnitStream.Seek(ExtendedLength, soFromCurrent);
            end;

          else
            // unknown extended opcode
            UnitStream.Seek(ExtendedLength, soFromCurrent);
          end;
        end;

        // The DW_LNS_copy opcode takes no operands. It appends a row to the matrix using the
        // current values of the state-machine registers. Then it sets the discriminator register
        // to 0, and sets the basic_block, prologue_end and epilogue_begin registers to “false.”

        DW_LNS_copy:
        begin
          SmRegisters.discriminator := 0;
          SmRegisters.basic_block := False;
          SmRegisters.prolouge_end := False;
          SmRegisters.epilouge_begin := False;
          AddToMatrix := True;
        end;

        // The DW_LNS_advance_pc opcode takes a single unsigned LEB128 operand, multiplies it by
        // the minimum_instruction_length field of the header, and adds the result to the address
        // register of the state machine.

        DW_LNS_advance_pc:
        begin
          if Header64.version < 5 then
            SmRegisters.address := SmRegisters.address +
              UnitStream.ReadULEB128 * Header64.minimum_instruction_length
          else
          begin
            // The DW_LNS_advance_pc opcode takes a single unsigned LEB128 operand
            // as the operation advance and modifies the address and op_index registers as
            // specified in Section 6.2.5.1 on page 160.
            RaiseNotImplemented(Header64.version);
          end;
        end;

        // The DW_LNS_advance_line opcode takes a single signed LEB128 operand and adds that
        // value to the line register of the state machine.

        DW_LNS_advance_line:
        begin
          SmRegisters.line := SmRegisters.line + UnitStream.ReadLEB128;
        end;

        // The DW_LNS_set_file opcode takes a single unsigned LEB128 operand and stores it in the
        // file register of the state machine.

        DW_LNS_set_file:
        begin
          SmRegisters.file_id := UnitStream.ReadULEB128;
        end;

        // The DW_LNS_set_column opcode takes a single unsigned LEB128 operand and stores it in
        // the column register of the state machine

        DW_LNS_set_column:
        begin
          SmRegisters.column := UnitStream.ReadULEB128;
        end;

        // The DW_LNS_negate_stmt opcode takes no operands. It sets the is_stmt register of the
        // state machine to the logical negation of its current value.

        DW_LNS_negate_stmt:
        begin
          SmRegisters.is_stmt := not SmRegisters.is_stmt;
        end;

        // The DW_LNS_set_basic_block opcode takes no operands. It sets the basic_block register
        // of the state machine to “true.”

        DW_LNS_set_basic_block:
        begin
          SmRegisters.basic_block := True;
        end;

        // The DW_LNS_const_add_pc opcode takes no operands. It multiplies the address increment
        // value corresponding to special opcode 255 by the minimum_instruction_length field of
        // the header, and adds the result to the address register of the state machine.

        // When the line number program needs to advance the address by a small amount, it can use a
        // single special opcode, which occupies a single byte. When it needs to advance the address by
        // up to twice the range of the last special opcode, it can use DW_LNS_const_add_pc followed
        // by a special opcode, for a total of two bytes. Only if it needs to advance the address by more
        // than twice that range will it need to use both DW_LNS_advance_pc and a special opcode,
        // requiring three or more bytes.

        DW_LNS_const_add_pc:
        begin
          if Header64.version < 5 then
          begin
            SmRegisters.address := SmRegisters.address + CalcAddPCValue(255, Header64);
          end
          else
          begin
            // The DW_LNS_const_add_pc opcode takes no operands. It advances the
            // address and op_index registers by the increments corresponding to special
            // opcode 255.
            RaiseNotImplemented(Header64.version);
          end;
        end;

        // The DW_LNS_fixed_advance_pc opcode takes a single uhalf (unencoded) operand and adds
        // it to the address register of the state machine. This is the only standard opcode whose
        // operand is not a variable length number. It also does not multiply the operand by the
        // minimum_instruction_length field of the header.

        // Existing assemblers cannot emit DW_LNS_advance_pc or special opcodes because they
        // cannot encode LEB128 numbers or judge when the computation of a special opcode
        // overflows and requires the use of DW_LNS_advance_pc. Such assemblers, however, can use
        // DW_LNS_fixed_advance_pc instead, sacrificing compression.

        DW_LNS_fixed_advance_pc:
        begin
          if Header64.version < 5 then
          begin
            SmRegisters.address := SmRegisters.address + UnitStream.ReadWord;
          end
          else
          begin
            // The DW_LNS_fixed_advance_pc opcode takes a single uhalf (unencoded)
            // operand and adds it to the address register of the state machine and sets the
            // op_index register to 0. This is the only standard opcode whose operand is not
            // a variable length number. It also does not multiply
            RaiseNotImplemented(Header64.version);
          end;
        end;

        // The DW_LNS_set_prologue_end opcode takes no operands. It sets the prologue_end
        // register to “true”.

        // When a breakpoint is set on entry to a function, it is generally desirable for execution to be
        // suspended, not on the very first instruction of the function, but rather at a point after the
        // function's frame has been set up, after any language defined local declaration processing has
        // been completed, and before execution of the first statement of the function begins. Debuggers
        // generally cannot properly determine where this point is. This command allows a compiler to
        // communicate the location(s) to use.

        // In the case of optimized code, there may be more than one such location; for example, the
        // code might test for a special case and make a fast exit prior to setting up the frame.

        // Note that the function to which the prologue end applies cannot be directly determined from
        // the line number information alone; it must be determined in combination with the subroutine
        // information entries of the compilation (including inlined subroutines).

        DW_LNS_set_prologue_end:
        begin
          SmRegisters.prolouge_end := True;
        end;

        // The DW_LNS_set_epilogue_begin opcode takes no operands. It sets the epilogue_begin
        // register to “true”.

        // When a breakpoint is set on the exit of a function or execution steps over the last executable
        // statement of a function, it is generally desirable to suspend execution after completion of the
        // last statement but prior to tearing down the frame (so that local variables can still be
        // examined). Debuggers generally cannot properly determine where this point is. This
        // command allows a compiler to communicate the location(s) to use.

        // Note that the function to which the epilogue end applies cannot be directly determined from
        // the line number information alone; it must be determined in combination with the subroutine
        // information entries of the compilation (including inlined subroutines).

        // In the case of a trivial function, both prologue end and epilogue begin may occur at the same
        // address.

        DW_LNS_set_epilogue_begin:
        begin
          SmRegisters.epilouge_begin := True;
        end;

        // The DW_LNS_set_isa opcode takes a single unsigned LEB128 operand and stores that value
        // in the isa register of the state machine.

        DW_LNS_set_isa:
        begin
          SmRegisters.isa := UnitStream.ReadULEB128;
        end;

      else

        // 6.2.5.1 Special Opcodes

        // Each ubyte special opcode has the following effect on the state machine:
        // 1. Add a signed integer to the line register.
        // 2. Multiply an unsigned integer by the minimum_instruction_length field of the line number
        // program header and add the result to the address register.

        // DWARF5
        // 2. Modify the operation pointer by incrementing the address and op_index
        // registers as described below

        // 3. Append a row to the matrix using the current values of the state machine registers.
        // 4. Set the basic_block register to “false.”
        // 5. Set the prologue_end register to “false.”
        // 6. Set the epilogue_begin register to “false.”
        // 7. Set the discriminator register to 0.

        // All of the special opcodes do those same six things; they differ from one another only in what
        // values they add to the line, address and op_index registers.

        if opcode < Header64.opcode_base then
        begin
          UnitStream.Seek(FOpcodeLen[opcode], soFromCurrent);
        end
        else
        begin

          // To decode a special opcode, subtract the opcode_base from the opcode itself to give the
          // adjusted opcode. The amount to increment the address register is the result of the adjusted
          // opcode divided by the line_range multiplied by the minimum_instruction_length field
          // from the header. That is,
          //  address increment = (adjusted opcode / line_range) * minimim_instruction_length

          SmRegisters.address := SmRegisters.address + CalcAddPCValue(opcode, Header64);

          // The amount to increment the line register is the line_base plus the result of the adjusted
          // opcode modulo the line_range. That is,
          //  line increment = line_base + (adjusted opcode % line_range)

          SmRegisters.line := SmRegisters.line + Header64.line_base +
            ((opcode - Header64.opcode_base) mod Header64.line_range);
        end;

        SmRegisters.basic_block := False;
        SmRegisters.prolouge_end := False;
        SmRegisters.epilouge_begin := False;
        AddToMatrix := True;

      end;

      if AddToMatrix and AddrVAInited then
      begin
        AddToMatrix := False;
        if SmRegisters.end_sequence then
        begin
          SmRegisters := InitStateMachineRegisters(Header64.default_is_stmt);
          AddrVAInited := False;
        end
        else
        begin
          SymbolData := MakeItem(SmRegisters.address, sdtDwarfLine);
          SymbolData.Dwarf.ModuleIndex := FModuleIndex;
          SymbolData.Dwarf.UnitIndex := FUnitIndex;
          SymbolData.Dwarf.LineIndex := FLines.Count;
          SymbolStorage.Add(SymbolData);

          LineData.AddrVA := SmRegisters.address;
          LineData.FileId := SmRegisters.file_id;
          LineData.Line := SmRegisters.line;
          FLines.Add(LineData);
        end;
      end;

      if UnitStream.EOF then
        Break;

      opcode := UnitStream.ReadByte;
    end;
  finally
    UnitStream.Free;
  end;

end;

{ TDwarfDebugInfo }

constructor TDwarfDebugInfo.Create(AImage: TAbstractImageGate);
begin
  FImage := AImage;
  FUnits := TUnitList.Create;
end;

destructor TDwarfDebugInfo.Destroy;
begin
  FUnits.Free;
  inherited;
end;

function TDwarfDebugInfo.Load(AStream: TStream): Boolean;
begin
  Result := True;
//  FImage.SectionAtName('.debug_abbrev', FAbbrevIndex);
//  FImage.SectionAtName('.debug_aranges', FArangesIndex);
//  FImage.SectionAtName('.debug_info', FInfoIndex);
//  FImage.SectionAtName('.debug_line', FLineIndex);
  try
    LoadLines(AStream);
  except
    Result := False;
  end;
  Result := Result and (FUnits.Count > 0);
end;

procedure TDwarfDebugInfo.LoadLines(AStream: TStream);
var
  ASection: TSectionParams;
  UnitData: TUnitDataStream;
  AUnit: TDwarfLinesUnit;
begin
  if not FImage.SectionAtName('.debug_line', ASection) then Exit;
  UnitData := TUnitDataStream.Create(AStream, ASection.AddressRaw, ASection.SizeOfRawData);
  try
    while not UnitData.EOF do
    begin
      AUnit := TDwarfLinesUnit.Create(FImage.ModuleIndex, FUnits.Count);
      try
        if not AUnit.Load(UnitData) then
        begin
          FreeAndNil(AUnit);
          Break;
        end;
        FUnits.Add(AUnit);
      except
        AUnit.Free;
        raise;
      end;
    end;
  finally
    UnitData.Free;
  end;
end;

end.
