Show Delphi/Lazarus Unit Init Order
================

Демонстрация работы с классами TDebugMap, TRawPEImage, TRawScannerSymbolStorage и TDisassembler.
Демо-пример реализует вывод списка используемых модулей в порядке их инициализации, включая вызовы классовых конструкторов/деструкторов.

### Внешний вид:

![1](https://github.com/AlexanderBagel/ProcessMemoryMap/blob/master/CommonDemo/ShowInitOrder/img/1.png?raw=true "Внешний вид")

### Принцип работы

В отладочной информации Delphi, конкретно в МАР файле отсутствует информация об адресе таблицы инициализации модулей, поэтому реализована функция LoadDelphiUnitInitOrder,
в которой дизассемблируется точка входа в приложение и производится поиск вызова функции "@InitExe" или "SysInit.@InitExe".
Данной функции на вход передается адрес заголовка таблицы инициализации, получив который производится парсинг таблицы.

В версии для Lazarus (функция LoadLazarusUnitInitOrder), адрес таблицы инициализации изначально присутствует в отладочных COFF символах под именем "INITFINAL".
Но, в отличии от Delphi, данная таблица инициализации не содержит вызовов классовых конструкторов/деструкторов. 
Они распологаются в функции инициализации того модуля, где обьявлен класс. Поэтому для определения вызовов классов конструкторов приозводится дизассемблирование
каждой процедуры инициализации/финализации с целью поиска таких вызовов.
Пока что разбор происходит только на основании COFF информации и в результат могут ошибочно попадать вызовы обычных конструкторов/деструкторов классов.
Как только будет подключен полный пакет DWARF информации, ошибочные вызовы должны быть исключены.
